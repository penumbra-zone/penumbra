// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IbcRelay {
    #[prost(message, optional, tag = "1")]
    pub raw_action: ::core::option::Option<::pbjson_types::Any>,
}
impl ::prost::Name for IbcRelay {
    const NAME: &'static str = "IbcRelay";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.IbcRelay".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.IbcRelay".into()
    }
}
/// FungibleTokenPacketData defines a struct for the packet payload
/// See FungibleTokenPacketData spec:
/// <https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FungibleTokenPacketData {
    /// the token denomination to be transferred
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
    /// the token amount to be transferred
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// the return address
    #[prost(string, tag = "3")]
    pub sender: ::prost::alloc::string::String,
    /// the recipient address on the destination chain
    #[prost(string, tag = "4")]
    pub receiver: ::prost::alloc::string::String,
    /// optional memo
    #[prost(string, tag = "5")]
    pub memo: ::prost::alloc::string::String,
}
impl ::prost::Name for FungibleTokenPacketData {
    const NAME: &'static str = "FungibleTokenPacketData";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.FungibleTokenPacketData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.FungibleTokenPacketData".into()
    }
}
/// A Penumbra transaction action requesting an ICS20 transfer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ics20Withdrawal {
    #[prost(message, optional, tag = "1")]
    pub amount: ::core::option::Option<super::super::super::num::v1::Amount>,
    #[prost(message, optional, tag = "2")]
    pub denom: ::core::option::Option<super::super::super::asset::v1::Denom>,
    /// the address on the destination chain to send the transfer to
    #[prost(string, tag = "3")]
    pub destination_chain_address: ::prost::alloc::string::String,
    /// a "sender" penumbra address to use to return funds from this withdrawal.
    /// this should be an ephemeral address
    #[prost(message, optional, tag = "4")]
    pub return_address: ::core::option::Option<super::super::super::keys::v1::Address>,
    /// The height on the counterparty chain at which this transfer expires, and
    /// funds are sent back to the return address.
    #[prost(message, optional, tag = "5")]
    pub timeout_height: ::core::option::Option<
        ::ibc_proto::ibc::core::client::v1::Height,
    >,
    /// The timestamp, in epoch time, after which this transfer will be considered invalid.
    /// Clients must quantize this value to the nearest minute, to preserve privacy.
    /// IBC withdrawals that do not quantize timestamps will be rejected.
    #[prost(uint64, tag = "6")]
    pub timeout_time: u64,
    /// The source channel used for the withdrawal
    #[prost(string, tag = "7")]
    pub source_channel: ::prost::alloc::string::String,
    /// Whether to use a "compat" (bech32, non-m) address for the return address in the withdrawal,
    /// for compatability with chains that expect to be able to parse the return address as bech32.
    #[deprecated]
    #[prost(bool, tag = "8")]
    pub use_compat_address: bool,
    /// Arbitrary string data to be included in the `memo` field
    /// of the ICS-20 FungibleTokenPacketData for this withdrawal.
    /// Commonly used for packet forwarding support, or other protocols that may support usage of the memo field.
    #[prost(string, tag = "9")]
    pub ics20_memo: ::prost::alloc::string::String,
    /// Whether to use a transparent address (bech32, 32-byte) for the return address in the withdrawal.
    #[prost(bool, tag = "10")]
    pub use_transparent_address: bool,
}
impl ::prost::Name for Ics20Withdrawal {
    const NAME: &'static str = "Ics20Withdrawal";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.Ics20Withdrawal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.Ics20Withdrawal".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientData {
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    /// NOTE: left as Any to allow us to add more client types later
    #[prost(message, optional, tag = "2")]
    pub client_state: ::core::option::Option<::pbjson_types::Any>,
    #[prost(string, tag = "3")]
    pub processed_time: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub processed_height: u64,
}
impl ::prost::Name for ClientData {
    const NAME: &'static str = "ClientData";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.ClientData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.ClientData".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientCounter {
    #[prost(uint64, tag = "1")]
    pub counter: u64,
}
impl ::prost::Name for ClientCounter {
    const NAME: &'static str = "ClientCounter";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.ClientCounter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.ClientCounter".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusState {
    #[prost(message, optional, tag = "1")]
    pub consensus_state: ::core::option::Option<::pbjson_types::Any>,
}
impl ::prost::Name for ConsensusState {
    const NAME: &'static str = "ConsensusState";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.ConsensusState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.ConsensusState".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiedHeights {
    #[prost(message, repeated, tag = "1")]
    pub heights: ::prost::alloc::vec::Vec<::ibc_proto::ibc::core::client::v1::Height>,
}
impl ::prost::Name for VerifiedHeights {
    const NAME: &'static str = "VerifiedHeights";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.VerifiedHeights".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.VerifiedHeights".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectionCounter {
    #[prost(uint64, tag = "1")]
    pub counter: u64,
}
impl ::prost::Name for ConnectionCounter {
    const NAME: &'static str = "ConnectionCounter";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.ConnectionCounter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.ConnectionCounter".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientConnections {
    #[prost(string, repeated, tag = "1")]
    pub connections: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ClientConnections {
    const NAME: &'static str = "ClientConnections";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.ClientConnections".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.ClientConnections".into()
    }
}
/// IBC configuration data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IbcParameters {
    /// Whether IBC (forming connections, processing IBC packets) is enabled.
    #[prost(bool, tag = "1")]
    pub ibc_enabled: bool,
    /// Whether inbound ICS-20 transfers are enabled
    #[prost(bool, tag = "2")]
    pub inbound_ics20_transfers_enabled: bool,
    /// Whether outbound ICS-20 transfers are enabled
    #[prost(bool, tag = "3")]
    pub outbound_ics20_transfers_enabled: bool,
}
impl ::prost::Name for IbcParameters {
    const NAME: &'static str = "IbcParameters";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.IbcParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.IbcParameters".into()
    }
}
/// IBC genesis state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenesisContent {
    /// IBC parameters.
    #[prost(message, optional, tag = "1")]
    pub ibc_params: ::core::option::Option<IbcParameters>,
}
impl ::prost::Name for GenesisContent {
    const NAME: &'static str = "GenesisContent";
    const PACKAGE: &'static str = "penumbra.core.component.ibc.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.component.ibc.v1.GenesisContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.component.ibc.v1.GenesisContent".into()
    }
}
