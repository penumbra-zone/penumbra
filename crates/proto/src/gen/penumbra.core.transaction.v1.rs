// This file is @generated by prost-build.
/// A Penumbra transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<TransactionBody>,
    /// The binding signature is stored separately from the transaction body that it signs.
    #[prost(message, optional, tag = "2")]
    pub binding_sig: ::core::option::Option<
        super::super::super::crypto::decaf377_rdsa::v1::BindingSignature,
    >,
    /// The root of some previous state of the state commitment tree, used as an anchor for all
    /// ZK state transition proofs.
    #[prost(message, optional, tag = "3")]
    pub anchor: ::core::option::Option<super::super::super::crypto::tct::v1::MerkleRoot>,
}
impl ::prost::Name for Transaction {
    const NAME: &'static str = "Transaction";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.Transaction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.Transaction".into()
    }
}
/// The body of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionBody {
    /// A list of actions (state changes) performed by this transaction.
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    /// Parameters determining if a transaction should be accepted by this chain.
    #[prost(message, optional, tag = "2")]
    pub transaction_parameters: ::core::option::Option<TransactionParameters>,
    /// Detection data for use with Fuzzy Message Detection
    #[prost(message, optional, tag = "4")]
    pub detection_data: ::core::option::Option<DetectionData>,
    /// The encrypted memo for this transaction.
    ///
    /// This field will be present if and only if the transaction has outputs.
    #[prost(message, optional, tag = "5")]
    pub memo: ::core::option::Option<MemoCiphertext>,
}
impl ::prost::Name for TransactionBody {
    const NAME: &'static str = "TransactionBody";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionBody".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionBody".into()
    }
}
/// The parameters determining if a transaction should be accepted by the chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionParameters {
    /// The maximum height that this transaction can be included in the chain.
    ///
    /// If zero, there is no maximum.
    #[prost(uint64, tag = "1")]
    pub expiry_height: u64,
    /// The chain this transaction is intended for.  Including this prevents
    /// replaying a transaction on one chain onto a different chain.
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    /// The transaction fee.
    #[prost(message, optional, tag = "3")]
    pub fee: ::core::option::Option<super::super::component::fee::v1::Fee>,
}
impl ::prost::Name for TransactionParameters {
    const NAME: &'static str = "TransactionParameters";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionParameters".into()
    }
}
/// Represents a transaction summary containing multiple effects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionSummary {
    #[prost(message, repeated, tag = "1")]
    pub effects: ::prost::alloc::vec::Vec<transaction_summary::Effects>,
}
/// Nested message and enum types in `TransactionSummary`.
pub mod transaction_summary {
    /// Represents an individual effect of a transaction.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Effects {
        #[prost(message, optional, tag = "1")]
        pub address: ::core::option::Option<super::super::super::keys::v1::AddressView>,
        #[prost(message, optional, tag = "2")]
        pub balance: ::core::option::Option<super::super::super::asset::v1::Balance>,
    }
    impl ::prost::Name for Effects {
        const NAME: &'static str = "Effects";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.TransactionSummary.Effects".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.TransactionSummary.Effects".into()
        }
    }
}
impl ::prost::Name for TransactionSummary {
    const NAME: &'static str = "TransactionSummary";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionSummary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionSummary".into()
    }
}
/// Detection data used by a detection server performing Fuzzy Message Detection.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectionData {
    /// A list of clues for use with Fuzzy Message Detection.
    #[prost(message, repeated, tag = "4")]
    pub fmd_clues: ::prost::alloc::vec::Vec<
        super::super::super::crypto::decaf377_fmd::v1::Clue,
    >,
}
impl ::prost::Name for DetectionData {
    const NAME: &'static str = "DetectionData";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.DetectionData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.DetectionData".into()
    }
}
/// A state change performed by a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(
        oneof = "action::Action",
        tags = "1, 2, 3, 4, 16, 17, 18, 19, 20, 21, 22, 30, 31, 32, 34, 40, 41, 42, 50, 51, 52, 53, 54, 55, 70, 200"
    )]
    pub action: ::core::option::Option<action::Action>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        /// Common actions have numbers \< 15, to save space.
        #[prost(message, tag = "1")]
        Spend(super::super::super::component::shielded_pool::v1::Spend),
        #[prost(message, tag = "2")]
        Output(super::super::super::component::shielded_pool::v1::Output),
        #[prost(message, tag = "3")]
        Swap(super::super::super::component::dex::v1::Swap),
        #[prost(message, tag = "4")]
        SwapClaim(super::super::super::component::dex::v1::SwapClaim),
        #[prost(message, tag = "16")]
        ValidatorDefinition(
            super::super::super::component::stake::v1::ValidatorDefinition,
        ),
        #[prost(message, tag = "17")]
        IbcRelayAction(super::super::super::component::ibc::v1::IbcRelay),
        /// Governance:
        #[prost(message, tag = "18")]
        ProposalSubmit(super::super::super::component::governance::v1::ProposalSubmit),
        #[prost(message, tag = "19")]
        ProposalWithdraw(
            super::super::super::component::governance::v1::ProposalWithdraw,
        ),
        #[prost(message, tag = "20")]
        ValidatorVote(super::super::super::component::governance::v1::ValidatorVote),
        #[prost(message, tag = "21")]
        DelegatorVote(super::super::super::component::governance::v1::DelegatorVote),
        #[prost(message, tag = "22")]
        ProposalDepositClaim(
            super::super::super::component::governance::v1::ProposalDepositClaim,
        ),
        /// Positions
        #[prost(message, tag = "30")]
        PositionOpen(super::super::super::component::dex::v1::PositionOpen),
        #[prost(message, tag = "31")]
        PositionClose(super::super::super::component::dex::v1::PositionClose),
        #[prost(message, tag = "32")]
        PositionWithdraw(super::super::super::component::dex::v1::PositionWithdraw),
        #[prost(message, tag = "34")]
        PositionRewardClaim(
            super::super::super::component::dex::v1::PositionRewardClaim,
        ),
        /// (un)delegation
        #[prost(message, tag = "40")]
        Delegate(super::super::super::component::stake::v1::Delegate),
        #[prost(message, tag = "41")]
        Undelegate(super::super::super::component::stake::v1::Undelegate),
        #[prost(message, tag = "42")]
        UndelegateClaim(super::super::super::component::stake::v1::UndelegateClaim),
        /// Community Pool
        #[prost(message, tag = "50")]
        CommunityPoolSpend(
            super::super::super::component::governance::v1::CommunityPoolSpend,
        ),
        #[prost(message, tag = "51")]
        CommunityPoolOutput(
            super::super::super::component::governance::v1::CommunityPoolOutput,
        ),
        #[prost(message, tag = "52")]
        CommunityPoolDeposit(
            super::super::super::component::governance::v1::CommunityPoolDeposit,
        ),
        /// Dutch auctions
        #[prost(message, tag = "53")]
        ActionDutchAuctionSchedule(
            super::super::super::component::auction::v1::ActionDutchAuctionSchedule,
        ),
        #[prost(message, tag = "54")]
        ActionDutchAuctionEnd(
            super::super::super::component::auction::v1::ActionDutchAuctionEnd,
        ),
        #[prost(message, tag = "55")]
        ActionDutchAuctionWithdraw(
            super::super::super::component::auction::v1::ActionDutchAuctionWithdraw,
        ),
        /// Funding
        #[prost(message, tag = "70")]
        ActionLiquidityTournamentVote(
            super::super::super::component::funding::v1::ActionLiquidityTournamentVote,
        ),
        #[prost(message, tag = "200")]
        Ics20Withdrawal(super::super::super::component::ibc::v1::Ics20Withdrawal),
    }
}
impl ::prost::Name for Action {
    const NAME: &'static str = "Action";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.Action".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.Action".into()
    }
}
/// A transaction perspective is a bundle of key material and commitment openings
/// that allow generating a view of a transaction from that perspective.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionPerspective {
    #[prost(message, repeated, tag = "1")]
    pub payload_keys: ::prost::alloc::vec::Vec<PayloadKeyWithCommitment>,
    #[prost(message, repeated, tag = "2")]
    pub spend_nullifiers: ::prost::alloc::vec::Vec<NullifierWithNote>,
    /// The openings of note commitments referred to in the transaction
    /// but not included in the transaction.
    #[prost(message, repeated, tag = "3")]
    pub advice_notes: ::prost::alloc::vec::Vec<
        super::super::component::shielded_pool::v1::Note,
    >,
    /// Any relevant address views.
    #[prost(message, repeated, tag = "4")]
    pub address_views: ::prost::alloc::vec::Vec<super::super::keys::v1::AddressView>,
    /// Any relevant denoms for viewed assets.
    #[prost(message, repeated, tag = "5")]
    pub denoms: ::prost::alloc::vec::Vec<super::super::asset::v1::Metadata>,
    /// The transaction ID associated with this TransactionPerspective
    #[prost(message, optional, tag = "6")]
    pub transaction_id: ::core::option::Option<super::super::txhash::v1::TransactionId>,
    /// Any relevant estimated prices
    #[prost(message, repeated, tag = "20")]
    pub prices: ::prost::alloc::vec::Vec<super::super::asset::v1::EstimatedPrice>,
    /// Any relevant extended metadata, indexed by asset id.
    #[prost(message, repeated, tag = "30")]
    pub extended_metadata: ::prost::alloc::vec::Vec<
        transaction_perspective::ExtendedMetadataById,
    >,
    #[prost(message, repeated, tag = "40")]
    pub creation_transaction_ids_by_nullifier: ::prost::alloc::vec::Vec<
        transaction_perspective::CreationTransactionIdByNullifier,
    >,
    #[prost(message, repeated, tag = "50")]
    pub nullification_transaction_ids_by_commitment: ::prost::alloc::vec::Vec<
        transaction_perspective::NullificationTransactionIdByCommitment,
    >,
    /// Any relevant BatchSwapOutputData to the transaction.
    ///
    /// This can be used to fill in information about swap outputs.
    #[prost(message, repeated, tag = "60")]
    pub batch_swap_output_data: ::prost::alloc::vec::Vec<
        super::super::component::dex::v1::BatchSwapOutputData,
    >,
    #[prost(message, optional, tag = "70")]
    pub position_metadata_key: ::core::option::Option<
        super::super::keys::v1::PositionMetadataKey,
    >,
}
/// Nested message and enum types in `TransactionPerspective`.
pub mod transaction_perspective {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExtendedMetadataById {
        #[prost(message, optional, tag = "1")]
        pub asset_id: ::core::option::Option<super::super::super::asset::v1::AssetId>,
        #[prost(message, optional, tag = "2")]
        pub extended_metadata: ::core::option::Option<::pbjson_types::Any>,
    }
    impl ::prost::Name for ExtendedMetadataById {
        const NAME: &'static str = "ExtendedMetadataById";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.TransactionPerspective.ExtendedMetadataById"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.TransactionPerspective.ExtendedMetadataById"
                .into()
        }
    }
    /// Associates a nullifier with the transaction ID that created the nullified state commitment.
    ///
    /// Note: this is *not* the transaction ID that revealed the nullifier.
    ///
    /// Allows walking backwards from a spend to the transaction that created the note.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreationTransactionIdByNullifier {
        #[prost(message, optional, tag = "1")]
        pub nullifier: ::core::option::Option<
            super::super::super::component::sct::v1::Nullifier,
        >,
        #[prost(message, optional, tag = "2")]
        pub transaction_id: ::core::option::Option<
            super::super::super::txhash::v1::TransactionId,
        >,
    }
    impl ::prost::Name for CreationTransactionIdByNullifier {
        const NAME: &'static str = "CreationTransactionIdByNullifier";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.TransactionPerspective.CreationTransactionIdByNullifier"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.TransactionPerspective.CreationTransactionIdByNullifier"
                .into()
        }
    }
    /// Associates a commitment with the transaction ID that eventually nullified it.
    ///
    /// Allows walking forwards from an output to the transaction that spent the note.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NullificationTransactionIdByCommitment {
        #[prost(message, optional, tag = "1")]
        pub commitment: ::core::option::Option<
            super::super::super::super::crypto::tct::v1::StateCommitment,
        >,
        #[prost(message, optional, tag = "2")]
        pub transaction_id: ::core::option::Option<
            super::super::super::txhash::v1::TransactionId,
        >,
    }
    impl ::prost::Name for NullificationTransactionIdByCommitment {
        const NAME: &'static str = "NullificationTransactionIdByCommitment";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.TransactionPerspective.NullificationTransactionIdByCommitment"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.TransactionPerspective.NullificationTransactionIdByCommitment"
                .into()
        }
    }
}
impl ::prost::Name for TransactionPerspective {
    const NAME: &'static str = "TransactionPerspective";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionPerspective".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionPerspective".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayloadKeyWithCommitment {
    #[prost(message, optional, tag = "1")]
    pub payload_key: ::core::option::Option<super::super::keys::v1::PayloadKey>,
    #[prost(message, optional, tag = "2")]
    pub commitment: ::core::option::Option<
        super::super::super::crypto::tct::v1::StateCommitment,
    >,
}
impl ::prost::Name for PayloadKeyWithCommitment {
    const NAME: &'static str = "PayloadKeyWithCommitment";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.PayloadKeyWithCommitment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.PayloadKeyWithCommitment".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NullifierWithNote {
    #[prost(message, optional, tag = "1")]
    pub nullifier: ::core::option::Option<super::super::component::sct::v1::Nullifier>,
    #[prost(message, optional, tag = "2")]
    pub note: ::core::option::Option<super::super::component::shielded_pool::v1::Note>,
}
impl ::prost::Name for NullifierWithNote {
    const NAME: &'static str = "NullifierWithNote";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.NullifierWithNote".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.NullifierWithNote".into()
    }
}
/// View of a Penumbra transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionView {
    /// View of the transaction body
    #[prost(message, optional, tag = "1")]
    pub body_view: ::core::option::Option<TransactionBodyView>,
    /// The binding signature is stored separately from the transaction body that it signs.
    #[prost(message, optional, tag = "2")]
    pub binding_sig: ::core::option::Option<
        super::super::super::crypto::decaf377_rdsa::v1::BindingSignature,
    >,
    /// The root of some previous state of the state commitment tree, used as an anchor for all
    /// ZK state transition proofs.
    #[prost(message, optional, tag = "3")]
    pub anchor: ::core::option::Option<super::super::super::crypto::tct::v1::MerkleRoot>,
}
impl ::prost::Name for TransactionView {
    const NAME: &'static str = "TransactionView";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionView".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionBodyView {
    /// A list views into of actions (state changes) performed by this transaction.
    #[prost(message, repeated, tag = "1")]
    pub action_views: ::prost::alloc::vec::Vec<ActionView>,
    /// Transaction parameters.
    #[prost(message, optional, tag = "2")]
    pub transaction_parameters: ::core::option::Option<TransactionParameters>,
    /// The detection data in this transaction, only populated if
    /// there are outputs in the actions of this transaction.
    #[prost(message, optional, tag = "4")]
    pub detection_data: ::core::option::Option<DetectionData>,
    /// An optional view of a transaction memo. It will only be populated if there are
    /// outputs in the actions of this transaction.
    #[prost(message, optional, tag = "5")]
    pub memo_view: ::core::option::Option<MemoView>,
}
impl ::prost::Name for TransactionBodyView {
    const NAME: &'static str = "TransactionBodyView";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionBodyView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionBodyView".into()
    }
}
/// A view of a specific state change action performed by a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionView {
    #[prost(
        oneof = "action_view::ActionView",
        tags = "1, 2, 3, 4, 21, 35, 16, 17, 18, 19, 20, 22, 30, 31, 32, 34, 41, 42, 50, 51, 52, 53, 54, 55, 43, 70, 200"
    )]
    pub action_view: ::core::option::Option<action_view::ActionView>,
}
/// Nested message and enum types in `ActionView`.
pub mod action_view {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ActionView {
        /// Action types with visible/opaque variants
        #[prost(message, tag = "1")]
        Spend(super::super::super::component::shielded_pool::v1::SpendView),
        #[prost(message, tag = "2")]
        Output(super::super::super::component::shielded_pool::v1::OutputView),
        #[prost(message, tag = "3")]
        Swap(super::super::super::component::dex::v1::SwapView),
        #[prost(message, tag = "4")]
        SwapClaim(super::super::super::component::dex::v1::SwapClaimView),
        #[prost(message, tag = "21")]
        DelegatorVote(super::super::super::component::governance::v1::DelegatorVoteView),
        #[prost(message, tag = "35")]
        PositionOpenView(super::super::super::component::dex::v1::PositionOpenView),
        /// Action types without visible/opaque variants
        #[prost(message, tag = "16")]
        ValidatorDefinition(
            super::super::super::component::stake::v1::ValidatorDefinition,
        ),
        #[prost(message, tag = "17")]
        IbcRelayAction(super::super::super::component::ibc::v1::IbcRelay),
        /// Governance:
        #[prost(message, tag = "18")]
        ProposalSubmit(super::super::super::component::governance::v1::ProposalSubmit),
        #[prost(message, tag = "19")]
        ProposalWithdraw(
            super::super::super::component::governance::v1::ProposalWithdraw,
        ),
        #[prost(message, tag = "20")]
        ValidatorVote(super::super::super::component::governance::v1::ValidatorVote),
        #[prost(message, tag = "22")]
        ProposalDepositClaim(
            super::super::super::component::governance::v1::ProposalDepositClaim,
        ),
        /// Deprecated: UIP-9 requires us to have an actual view here.
        #[prost(message, tag = "30")]
        PositionOpen(super::super::super::component::dex::v1::PositionOpen),
        #[prost(message, tag = "31")]
        PositionClose(super::super::super::component::dex::v1::PositionClose),
        #[prost(message, tag = "32")]
        PositionWithdraw(super::super::super::component::dex::v1::PositionWithdraw),
        #[prost(message, tag = "34")]
        PositionRewardClaim(
            super::super::super::component::dex::v1::PositionRewardClaim,
        ),
        #[prost(message, tag = "41")]
        Delegate(super::super::super::component::stake::v1::Delegate),
        #[prost(message, tag = "42")]
        Undelegate(super::super::super::component::stake::v1::Undelegate),
        /// Community Pool
        #[prost(message, tag = "50")]
        CommunityPoolSpend(
            super::super::super::component::governance::v1::CommunityPoolSpend,
        ),
        #[prost(message, tag = "51")]
        CommunityPoolOutput(
            super::super::super::component::governance::v1::CommunityPoolOutput,
        ),
        #[prost(message, tag = "52")]
        CommunityPoolDeposit(
            super::super::super::component::governance::v1::CommunityPoolDeposit,
        ),
        /// Dutch auctions
        #[prost(message, tag = "53")]
        ActionDutchAuctionSchedule(
            super::super::super::component::auction::v1::ActionDutchAuctionScheduleView,
        ),
        #[prost(message, tag = "54")]
        ActionDutchAuctionEnd(
            super::super::super::component::auction::v1::ActionDutchAuctionEnd,
        ),
        #[prost(message, tag = "55")]
        ActionDutchAuctionWithdraw(
            super::super::super::component::auction::v1::ActionDutchAuctionWithdrawView,
        ),
        /// TODO: we have no way to recover the opening of the undelegate_claim's
        /// balance commitment, and can only infer the value from looking at the rest
        /// of the transaction. is that fine?
        #[prost(message, tag = "43")]
        UndelegateClaim(super::super::super::component::stake::v1::UndelegateClaim),
        #[prost(message, tag = "70")]
        ActionLiquidityTournamentVote(
            super::super::super::component::funding::v1::ActionLiquidityTournamentVoteView,
        ),
        #[prost(message, tag = "200")]
        Ics20Withdrawal(super::super::super::component::ibc::v1::Ics20Withdrawal),
    }
}
impl ::prost::Name for ActionView {
    const NAME: &'static str = "ActionView";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.ActionView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.ActionView".into()
    }
}
/// The data required to authorize a transaction plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationData {
    /// The computed auth hash for the approved transaction plan.
    #[prost(message, optional, tag = "1")]
    pub effect_hash: ::core::option::Option<super::super::txhash::v1::EffectHash>,
    /// The required spend authorizations, returned in the same order as the
    /// Spend actions in the original request.
    #[prost(message, repeated, tag = "2")]
    pub spend_auths: ::prost::alloc::vec::Vec<
        super::super::super::crypto::decaf377_rdsa::v1::SpendAuthSignature,
    >,
    /// The required delegator vote authorizations, returned in the same order as the
    /// DelegatorVote actions in the original request.
    #[prost(message, repeated, tag = "3")]
    pub delegator_vote_auths: ::prost::alloc::vec::Vec<
        super::super::super::crypto::decaf377_rdsa::v1::SpendAuthSignature,
    >,
    /// The required LQT vote authorizations, in the same order as the original request.
    #[prost(message, repeated, tag = "4")]
    pub lqt_vote_auths: ::prost::alloc::vec::Vec<
        super::super::super::crypto::decaf377_rdsa::v1::SpendAuthSignature,
    >,
}
impl ::prost::Name for AuthorizationData {
    const NAME: &'static str = "AuthorizationData";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.AuthorizationData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.AuthorizationData".into()
    }
}
/// The data required for proving when building a transaction from a plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WitnessData {
    /// The anchor for the state transition proofs.
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<super::super::super::crypto::tct::v1::MerkleRoot>,
    /// The auth paths for the notes the transaction spends, in the
    /// same order as the spends in the transaction plan.
    #[prost(message, repeated, tag = "2")]
    pub state_commitment_proofs: ::prost::alloc::vec::Vec<
        super::super::super::crypto::tct::v1::StateCommitmentProof,
    >,
}
impl ::prost::Name for WitnessData {
    const NAME: &'static str = "WitnessData";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.WitnessData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.WitnessData".into()
    }
}
/// Describes a planned transaction. Permits clients to prepare a transaction
/// prior submission, so that a user can review it prior to authorizing its execution.
///
/// The `TransactionPlan` is a fully determined bundle binding all of a transaction's effects.
/// The only thing it does not include is the witness data used for proving.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionPlan {
    /// The sequence of actions planned for this transaction.
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<ActionPlan>,
    /// Parameters determining if a transaction should be accepted by this chain.
    #[prost(message, optional, tag = "2")]
    pub transaction_parameters: ::core::option::Option<TransactionParameters>,
    /// Detection data for use with Fuzzy Message Detection
    #[prost(message, optional, tag = "4")]
    pub detection_data: ::core::option::Option<DetectionDataPlan>,
    /// The memo plan for this transaction.
    #[prost(message, optional, tag = "5")]
    pub memo: ::core::option::Option<MemoPlan>,
}
impl ::prost::Name for TransactionPlan {
    const NAME: &'static str = "TransactionPlan";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.TransactionPlan".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.TransactionPlan".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectionDataPlan {
    #[prost(message, repeated, tag = "5")]
    pub clue_plans: ::prost::alloc::vec::Vec<CluePlan>,
}
impl ::prost::Name for DetectionDataPlan {
    const NAME: &'static str = "DetectionDataPlan";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.DetectionDataPlan".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.DetectionDataPlan".into()
    }
}
/// Describes a planned transaction action.
///
/// Some transaction Actions don't have any private data and are treated as being plans
/// themselves.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionPlan {
    #[prost(
        oneof = "action_plan::Action",
        tags = "1, 2, 3, 4, 16, 17, 18, 19, 20, 21, 22, 200, 30, 35, 31, 32, 34, 40, 41, 42, 50, 51, 52, 53, 54, 55, 70"
    )]
    pub action: ::core::option::Option<action_plan::Action>,
}
/// Nested message and enum types in `ActionPlan`.
pub mod action_plan {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "1")]
        Spend(super::super::super::component::shielded_pool::v1::SpendPlan),
        #[prost(message, tag = "2")]
        Output(super::super::super::component::shielded_pool::v1::OutputPlan),
        #[prost(message, tag = "3")]
        Swap(super::super::super::component::dex::v1::SwapPlan),
        #[prost(message, tag = "4")]
        SwapClaim(super::super::super::component::dex::v1::SwapClaimPlan),
        /// This is just a message relayed to the chain.
        #[prost(message, tag = "16")]
        ValidatorDefinition(
            super::super::super::component::stake::v1::ValidatorDefinition,
        ),
        /// This is just a message relayed to the chain.
        #[prost(message, tag = "17")]
        IbcRelayAction(super::super::super::component::ibc::v1::IbcRelay),
        /// Governance:
        #[prost(message, tag = "18")]
        ProposalSubmit(super::super::super::component::governance::v1::ProposalSubmit),
        #[prost(message, tag = "19")]
        ProposalWithdraw(
            super::super::super::component::governance::v1::ProposalWithdraw,
        ),
        #[prost(message, tag = "20")]
        ValidatorVote(super::super::super::component::governance::v1::ValidatorVote),
        #[prost(message, tag = "21")]
        DelegatorVote(super::super::super::component::governance::v1::DelegatorVotePlan),
        #[prost(message, tag = "22")]
        ProposalDepositClaim(
            super::super::super::component::governance::v1::ProposalDepositClaim,
        ),
        #[prost(message, tag = "200")]
        Ics20Withdrawal(super::super::super::component::ibc::v1::Ics20Withdrawal),
        #[prost(message, tag = "30")]
        PositionOpen(super::super::super::component::dex::v1::PositionOpen),
        #[prost(message, tag = "35")]
        PositionOpenPlan(super::super::super::component::dex::v1::PositionOpenPlan),
        #[prost(message, tag = "31")]
        PositionClose(super::super::super::component::dex::v1::PositionClose),
        /// The position withdraw/reward claim actions require balance information so they have Plan types.
        #[prost(message, tag = "32")]
        PositionWithdraw(super::super::super::component::dex::v1::PositionWithdrawPlan),
        #[prost(message, tag = "34")]
        PositionRewardClaim(
            super::super::super::component::dex::v1::PositionRewardClaimPlan,
        ),
        /// We don't need any extra information (yet) to understand delegations,
        /// because we don't yet use flow encryption.
        #[prost(message, tag = "40")]
        Delegate(super::super::super::component::stake::v1::Delegate),
        /// We don't need any extra information (yet) to understand undelegations,
        /// because we don't yet use flow encryption.
        #[prost(message, tag = "41")]
        Undelegate(super::super::super::component::stake::v1::Undelegate),
        #[prost(message, tag = "42")]
        UndelegateClaim(super::super::super::component::stake::v1::UndelegateClaimPlan),
        /// Community Pool
        #[prost(message, tag = "50")]
        CommunityPoolSpend(
            super::super::super::component::governance::v1::CommunityPoolSpend,
        ),
        #[prost(message, tag = "51")]
        CommunityPoolOutput(
            super::super::super::component::governance::v1::CommunityPoolOutput,
        ),
        #[prost(message, tag = "52")]
        CommunityPoolDeposit(
            super::super::super::component::governance::v1::CommunityPoolDeposit,
        ),
        /// Dutch auctions
        #[prost(message, tag = "53")]
        ActionDutchAuctionSchedule(
            super::super::super::component::auction::v1::ActionDutchAuctionSchedule,
        ),
        #[prost(message, tag = "54")]
        ActionDutchAuctionEnd(
            super::super::super::component::auction::v1::ActionDutchAuctionEnd,
        ),
        #[prost(message, tag = "55")]
        ActionDutchAuctionWithdraw(
            super::super::super::component::auction::v1::ActionDutchAuctionWithdrawPlan,
        ),
        /// Funding
        #[prost(message, tag = "70")]
        ActionLiquidityTournamentVote(
            super::super::super::component::funding::v1::ActionLiquidityTournamentVotePlan,
        ),
    }
}
impl ::prost::Name for ActionPlan {
    const NAME: &'static str = "ActionPlan";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.ActionPlan".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.ActionPlan".into()
    }
}
/// Describes a plan for forming a `Clue`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CluePlan {
    /// The address.
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<super::super::keys::v1::Address>,
    /// The random seed to use for the clue plan.
    #[prost(bytes = "vec", tag = "2")]
    pub rseed: ::prost::alloc::vec::Vec<u8>,
    /// The bits of precision.
    #[prost(uint64, tag = "3")]
    pub precision_bits: u64,
}
impl ::prost::Name for CluePlan {
    const NAME: &'static str = "CluePlan";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.CluePlan".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.CluePlan".into()
    }
}
/// Describes a plan for forming the transaction memo.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoPlan {
    /// The plaintext.
    #[prost(message, optional, tag = "1")]
    pub plaintext: ::core::option::Option<MemoPlaintext>,
    /// The key to use to encrypt the memo.
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MemoPlan {
    const NAME: &'static str = "MemoPlan";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.MemoPlan".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.MemoPlan".into()
    }
}
/// The encrypted memo data describing information about the purpose of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoCiphertext {
    /// The encrypted data. 528 bytes.
    #[prost(bytes = "vec", tag = "1")]
    pub inner: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MemoCiphertext {
    const NAME: &'static str = "MemoCiphertext";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.MemoCiphertext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.MemoCiphertext".into()
    }
}
/// The plaintext describing information about the purpose of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoPlaintext {
    /// The sender's return address.
    ///
    /// This should always be a valid address; the sender is responsible for ensuring
    /// that if the receiver returns funds to this address, they will not be lost.
    #[prost(message, optional, tag = "1")]
    pub return_address: ::core::option::Option<super::super::keys::v1::Address>,
    /// Free-form text, up to 432 bytes long.
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for MemoPlaintext {
    const NAME: &'static str = "MemoPlaintext";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.MemoPlaintext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.MemoPlaintext".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoPlaintextView {
    #[prost(message, optional, tag = "1")]
    pub return_address: ::core::option::Option<super::super::keys::v1::AddressView>,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for MemoPlaintextView {
    const NAME: &'static str = "MemoPlaintextView";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.MemoPlaintextView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.MemoPlaintextView".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoView {
    #[prost(oneof = "memo_view::MemoView", tags = "1, 2")]
    pub memo_view: ::core::option::Option<memo_view::MemoView>,
}
/// Nested message and enum types in `MemoView`.
pub mod memo_view {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Visible {
        #[prost(message, optional, tag = "1")]
        pub ciphertext: ::core::option::Option<super::MemoCiphertext>,
        #[prost(message, optional, tag = "2")]
        pub plaintext: ::core::option::Option<super::MemoPlaintextView>,
    }
    impl ::prost::Name for Visible {
        const NAME: &'static str = "Visible";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.MemoView.Visible".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.MemoView.Visible".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Opaque {
        #[prost(message, optional, tag = "1")]
        pub ciphertext: ::core::option::Option<super::MemoCiphertext>,
    }
    impl ::prost::Name for Opaque {
        const NAME: &'static str = "Opaque";
        const PACKAGE: &'static str = "penumbra.core.transaction.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "penumbra.core.transaction.v1.MemoView.Opaque".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/penumbra.core.transaction.v1.MemoView.Opaque".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MemoView {
        #[prost(message, tag = "1")]
        Visible(Visible),
        #[prost(message, tag = "2")]
        Opaque(Opaque),
    }
}
impl ::prost::Name for MemoView {
    const NAME: &'static str = "MemoView";
    const PACKAGE: &'static str = "penumbra.core.transaction.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.core.transaction.v1.MemoView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.core.transaction.v1.MemoView".into()
    }
}
