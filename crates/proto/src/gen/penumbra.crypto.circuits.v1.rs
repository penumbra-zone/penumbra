// This file is @generated by prost-build.
/// Circuit for spend actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpendCircuit {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<SpendProofPublic>,
    #[prost(message, optional, tag = "2")]
    pub private: ::core::option::Option<SpendProofPrivate>,
}
impl ::prost::Name for SpendCircuit {
    const NAME: &'static str = "SpendCircuit";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SpendCircuit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SpendCircuit".into()
    }
}
/// Public inputs for spend proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpendProofPublic {
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<super::super::tct::v1::MerkleRoot>,
    #[prost(message, optional, tag = "2")]
    pub balance_commitment: ::core::option::Option<
        super::super::super::core::asset::v1::BalanceCommitment,
    >,
    #[prost(message, optional, tag = "3")]
    pub nullifier: ::core::option::Option<
        super::super::super::core::component::sct::v1::Nullifier,
    >,
    #[prost(message, optional, tag = "4")]
    pub rk: ::core::option::Option<
        super::super::decaf377_rdsa::v1::SpendVerificationKey,
    >,
}
impl ::prost::Name for SpendProofPublic {
    const NAME: &'static str = "SpendProofPublic";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SpendProofPublic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SpendProofPublic".into()
    }
}
/// Private inputs for spend proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpendProofPrivate {
    #[prost(message, optional, tag = "1")]
    pub state_commitment_proof: ::core::option::Option<
        super::super::tct::v1::StateCommitmentProof,
    >,
    #[prost(message, optional, tag = "2")]
    pub note: ::core::option::Option<
        super::super::super::core::component::shielded_pool::v1::Note,
    >,
    #[prost(bytes = "vec", tag = "3")]
    pub v_blinding: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub spend_auth_randomizer: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub ak: ::core::option::Option<
        super::super::decaf377_rdsa::v1::SpendAuthorizationKey,
    >,
    #[prost(message, optional, tag = "6")]
    pub nk: ::core::option::Option<
        super::super::decaf377_rdsa::v1::NullifierDerivingKey,
    >,
}
impl ::prost::Name for SpendProofPrivate {
    const NAME: &'static str = "SpendProofPrivate";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SpendProofPrivate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SpendProofPrivate".into()
    }
}
/// Circuit for output actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputCircuit {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<OutputProofPublic>,
    #[prost(message, optional, tag = "2")]
    pub private: ::core::option::Option<OutputProofPrivate>,
}
impl ::prost::Name for OutputCircuit {
    const NAME: &'static str = "OutputCircuit";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.OutputCircuit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.OutputCircuit".into()
    }
}
/// Public inputs for output proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputProofPublic {
    #[prost(message, optional, tag = "1")]
    pub balance_commitment: ::core::option::Option<
        super::super::super::core::asset::v1::BalanceCommitment,
    >,
    #[prost(message, optional, tag = "2")]
    pub note_commitment: ::core::option::Option<super::super::tct::v1::StateCommitment>,
}
impl ::prost::Name for OutputProofPublic {
    const NAME: &'static str = "OutputProofPublic";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.OutputProofPublic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.OutputProofPublic".into()
    }
}
/// Private inputs for output proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputProofPrivate {
    #[prost(message, optional, tag = "1")]
    pub note: ::core::option::Option<
        super::super::super::core::component::shielded_pool::v1::Note,
    >,
    /// Fr serialized
    #[prost(bytes = "vec", tag = "2")]
    pub balance_blinding: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for OutputProofPrivate {
    const NAME: &'static str = "OutputProofPrivate";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.OutputProofPrivate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.OutputProofPrivate".into()
    }
}
/// Circuit for swap actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapCircuit {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<SwapProofPublic>,
    #[prost(message, optional, tag = "2")]
    pub private: ::core::option::Option<SwapProofPrivate>,
}
impl ::prost::Name for SwapCircuit {
    const NAME: &'static str = "SwapCircuit";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapCircuit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapCircuit".into()
    }
}
/// Public inputs for swap proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapProofPublic {
    #[prost(message, optional, tag = "1")]
    pub balance_commitment: ::core::option::Option<
        super::super::super::core::asset::v1::BalanceCommitment,
    >,
    #[prost(message, optional, tag = "2")]
    pub swap_commitment: ::core::option::Option<super::super::tct::v1::StateCommitment>,
    #[prost(message, optional, tag = "3")]
    pub fee_commitment: ::core::option::Option<
        super::super::super::core::asset::v1::BalanceCommitment,
    >,
}
impl ::prost::Name for SwapProofPublic {
    const NAME: &'static str = "SwapProofPublic";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapProofPublic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapProofPublic".into()
    }
}
/// Private inputs for swap proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapProofPrivate {
    /// Fr serialized
    #[prost(bytes = "vec", tag = "1")]
    pub fee_blinding: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub swap_plaintext: ::core::option::Option<
        super::super::super::core::component::dex::v1::SwapPlaintext,
    >,
}
impl ::prost::Name for SwapProofPrivate {
    const NAME: &'static str = "SwapProofPrivate";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapProofPrivate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapProofPrivate".into()
    }
}
/// Circuit for swap claim actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapClaimCircuit {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<SwapClaimProofPublic>,
    #[prost(message, optional, tag = "2")]
    pub private: ::core::option::Option<SwapClaimProofPrivate>,
}
impl ::prost::Name for SwapClaimCircuit {
    const NAME: &'static str = "SwapClaimCircuit";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapClaimCircuit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapClaimCircuit".into()
    }
}
/// Public inputs for swap claim proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapClaimProofPublic {
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<super::super::tct::v1::MerkleRoot>,
    #[prost(message, optional, tag = "2")]
    pub nullifier: ::core::option::Option<
        super::super::super::core::component::sct::v1::Nullifier,
    >,
    #[prost(message, optional, tag = "3")]
    pub claim_fee: ::core::option::Option<
        super::super::super::core::component::fee::v1::Fee,
    >,
    #[prost(message, optional, tag = "4")]
    pub output_data: ::core::option::Option<
        super::super::super::core::component::dex::v1::BatchSwapOutputData,
    >,
    #[prost(message, optional, tag = "5")]
    pub note_commitment_1: ::core::option::Option<
        super::super::tct::v1::StateCommitment,
    >,
    #[prost(message, optional, tag = "6")]
    pub note_commitment_2: ::core::option::Option<
        super::super::tct::v1::StateCommitment,
    >,
}
impl ::prost::Name for SwapClaimProofPublic {
    const NAME: &'static str = "SwapClaimProofPublic";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapClaimProofPublic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapClaimProofPublic".into()
    }
}
/// Private inputs for swap claim proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapClaimProofPrivate {
    #[prost(message, optional, tag = "1")]
    pub swap_plaintext: ::core::option::Option<
        super::super::super::core::component::dex::v1::SwapPlaintext,
    >,
    #[prost(message, optional, tag = "2")]
    pub state_commitment_proof: ::core::option::Option<
        super::super::tct::v1::StateCommitmentProof,
    >,
    #[prost(message, optional, tag = "3")]
    pub ak: ::core::option::Option<
        super::super::decaf377_rdsa::v1::SpendAuthorizationKey,
    >,
    #[prost(message, optional, tag = "4")]
    pub nk: ::core::option::Option<
        super::super::decaf377_rdsa::v1::NullifierDerivingKey,
    >,
    #[prost(message, optional, tag = "5")]
    pub lambda_1: ::core::option::Option<super::super::super::core::num::v1::Amount>,
    #[prost(message, optional, tag = "6")]
    pub lambda_2: ::core::option::Option<super::super::super::core::num::v1::Amount>,
    /// Fq serialized
    #[prost(bytes = "vec", tag = "7")]
    pub note_blinding_1: ::prost::alloc::vec::Vec<u8>,
    /// Fq serialized
    #[prost(bytes = "vec", tag = "8")]
    pub note_blinding_2: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for SwapClaimProofPrivate {
    const NAME: &'static str = "SwapClaimProofPrivate";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.SwapClaimProofPrivate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.SwapClaimProofPrivate".into()
    }
}
/// Circuit for delegator vote actions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegatorVoteCircuit {
    #[prost(message, optional, tag = "1")]
    pub public: ::core::option::Option<DelegatorVoteProofPublic>,
    #[prost(message, optional, tag = "2")]
    pub private: ::core::option::Option<DelegatorVoteProofPrivate>,
}
impl ::prost::Name for DelegatorVoteCircuit {
    const NAME: &'static str = "DelegatorVoteCircuit";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.DelegatorVoteCircuit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.DelegatorVoteCircuit".into()
    }
}
/// Public inputs for delegator vote proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegatorVoteProofPublic {
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<super::super::tct::v1::MerkleRoot>,
    #[prost(message, optional, tag = "2")]
    pub balance_commitment: ::core::option::Option<
        super::super::super::core::asset::v1::BalanceCommitment,
    >,
    #[prost(message, optional, tag = "3")]
    pub nullifier: ::core::option::Option<
        super::super::super::core::component::sct::v1::Nullifier,
    >,
    #[prost(message, optional, tag = "4")]
    pub rk: ::core::option::Option<
        super::super::decaf377_rdsa::v1::SpendVerificationKey,
    >,
    /// tct::Position serialized as uint64
    #[prost(uint64, tag = "5")]
    pub start_position: u64,
}
impl ::prost::Name for DelegatorVoteProofPublic {
    const NAME: &'static str = "DelegatorVoteProofPublic";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.DelegatorVoteProofPublic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.DelegatorVoteProofPublic".into()
    }
}
/// Private inputs for delegator vote proof
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegatorVoteProofPrivate {
    #[prost(message, optional, tag = "1")]
    pub state_commitment_proof: ::core::option::Option<
        super::super::tct::v1::StateCommitmentProof,
    >,
    #[prost(message, optional, tag = "2")]
    pub note: ::core::option::Option<
        super::super::super::core::component::shielded_pool::v1::Note,
    >,
    /// Fr serialized
    #[prost(bytes = "vec", tag = "3")]
    pub v_blinding: ::prost::alloc::vec::Vec<u8>,
    /// Fr serialized
    #[prost(bytes = "vec", tag = "4")]
    pub spend_auth_randomizer: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub ak: ::core::option::Option<
        super::super::decaf377_rdsa::v1::SpendAuthorizationKey,
    >,
    #[prost(message, optional, tag = "6")]
    pub nk: ::core::option::Option<
        super::super::decaf377_rdsa::v1::NullifierDerivingKey,
    >,
}
impl ::prost::Name for DelegatorVoteProofPrivate {
    const NAME: &'static str = "DelegatorVoteProofPrivate";
    const PACKAGE: &'static str = "penumbra.crypto.circuits.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "penumbra.crypto.circuits.v1.DelegatorVoteProofPrivate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/penumbra.crypto.circuits.v1.DelegatorVoteProofPrivate".into()
    }
}
