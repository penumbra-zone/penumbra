// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: penumbra/view/v1alpha1/view.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Penumbra_View_V1alpha1_TransactionPerspectiveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Penumbra_View_V1alpha1_TransactionPerspectiveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txp: Penumbra_Core_Transaction_V1alpha1_TransactionPerspective {
    get {return _txp ?? Penumbra_Core_Transaction_V1alpha1_TransactionPerspective()}
    set {_txp = newValue}
  }
  /// Returns true if `txp` has been explicitly set.
  var hasTxp: Bool {return self._txp != nil}
  /// Clears the value of `txp`. Subsequent reads from it will return its default value.
  mutating func clearTxp() {self._txp = nil}

  var tx: Penumbra_Core_Transaction_V1alpha1_Transaction {
    get {return _tx ?? Penumbra_Core_Transaction_V1alpha1_Transaction()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _txp: Penumbra_Core_Transaction_V1alpha1_TransactionPerspective? = nil
  fileprivate var _tx: Penumbra_Core_Transaction_V1alpha1_Transaction? = nil
}

struct Penumbra_View_V1alpha1_TransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present, return only transactions after this height.
  var startHeight: UInt64 {
    get {return _startHeight ?? 0}
    set {_startHeight = newValue}
  }
  /// Returns true if `startHeight` has been explicitly set.
  var hasStartHeight: Bool {return self._startHeight != nil}
  /// Clears the value of `startHeight`. Subsequent reads from it will return its default value.
  mutating func clearStartHeight() {self._startHeight = nil}

  /// If present, return only transactions before this height.
  var endHeight: UInt64 {
    get {return _endHeight ?? 0}
    set {_endHeight = newValue}
  }
  /// Returns true if `endHeight` has been explicitly set.
  var hasEndHeight: Bool {return self._endHeight != nil}
  /// Clears the value of `endHeight`. Subsequent reads from it will return its default value.
  mutating func clearEndHeight() {self._endHeight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startHeight: UInt64? = nil
  fileprivate var _endHeight: UInt64? = nil
}

struct Penumbra_View_V1alpha1_TransactionByHashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction hash to query for.
  var txHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Penumbra_View_V1alpha1_TransactionHashStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: UInt64 = 0

  var txHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A streaming full transaction response
struct Penumbra_View_V1alpha1_TransactionStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: UInt64 = 0

  var txHash: Data = Data()

  var tx: Penumbra_Core_Transaction_V1alpha1_Transaction {
    get {return _tx ?? Penumbra_Core_Transaction_V1alpha1_Transaction()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Penumbra_Core_Transaction_V1alpha1_Transaction? = nil
}

/// A full transaction response
struct Penumbra_View_V1alpha1_TransactionByHashResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Penumbra_Core_Transaction_V1alpha1_Transaction {
    get {return _tx ?? Penumbra_Core_Transaction_V1alpha1_Transaction()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Penumbra_Core_Transaction_V1alpha1_Transaction? = nil
}

struct Penumbra_View_V1alpha1_NoteByCommitmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  var noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment {
    get {return _noteCommitment ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitment()}
    set {_noteCommitment = newValue}
  }
  /// Returns true if `noteCommitment` has been explicitly set.
  var hasNoteCommitment: Bool {return self._noteCommitment != nil}
  /// Clears the value of `noteCommitment`. Subsequent reads from it will return its default value.
  mutating func clearNoteCommitment() {self._noteCommitment = nil}

  /// If set to true, waits to return until the requested note is detected.
  var awaitDetection: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
  fileprivate var _noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment? = nil
}

/// Requests the current chain parameters from the view service.
struct Penumbra_View_V1alpha1_ChainParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Requests the current FMD parameters from the view service.
struct Penumbra_View_V1alpha1_FMDParametersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Requests all assets known to the view service.
struct Penumbra_View_V1alpha1_AssetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Requests sync status of the view service.
struct Penumbra_View_V1alpha1_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the FVK for the notes to query.
  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
}

/// Returns the status of the view service and whether it is synchronized with the chain state.
struct Penumbra_View_V1alpha1_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The height the view service has synchronized to so far
  var syncHeight: UInt64 = 0

  /// Whether the view service is catching up with the chain state
  var catchingUp: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Requests streaming updates on the sync height until the view service is synchronized.
struct Penumbra_View_V1alpha1_StatusStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the FVK for the notes to query.
  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
}

/// A streaming sync status update
struct Penumbra_View_V1alpha1_StatusStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latestKnownBlockHeight: UInt64 = 0

  var syncHeight: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A note plaintext with associated metadata about its status.
struct Penumbra_View_V1alpha1_SpendableNoteRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The note commitment, identifying the note.
  var noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment {
    get {return _noteCommitment ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitment()}
    set {_noteCommitment = newValue}
  }
  /// Returns true if `noteCommitment` has been explicitly set.
  var hasNoteCommitment: Bool {return self._noteCommitment != nil}
  /// Clears the value of `noteCommitment`. Subsequent reads from it will return its default value.
  mutating func clearNoteCommitment() {self._noteCommitment = nil}

  /// The note plaintext itself.
  var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  /// A precomputed decryption of the note's address incore.dex.v1alpha1.
  var addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex {
    get {return _addressIndex ?? Penumbra_Core_Crypto_V1alpha1_AddressIndex()}
    set {_addressIndex = newValue}
  }
  /// Returns true if `addressIndex` has been explicitly set.
  var hasAddressIndex: Bool {return self._addressIndex != nil}
  /// Clears the value of `addressIndex`. Subsequent reads from it will return its default value.
  mutating func clearAddressIndex() {self._addressIndex = nil}

  /// The note's nullifier.
  var nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier {
    get {return _nullifier ?? Penumbra_Core_Crypto_V1alpha1_Nullifier()}
    set {_nullifier = newValue}
  }
  /// Returns true if `nullifier` has been explicitly set.
  var hasNullifier: Bool {return self._nullifier != nil}
  /// Clears the value of `nullifier`. Subsequent reads from it will return its default value.
  mutating func clearNullifier() {self._nullifier = nil}

  /// The height at which the note was created.
  var heightCreated: UInt64 = 0

  /// Records whether the note was spent (and if so, at what height).
  var heightSpent: UInt64 {
    get {return _heightSpent ?? 0}
    set {_heightSpent = newValue}
  }
  /// Returns true if `heightSpent` has been explicitly set.
  var hasHeightSpent: Bool {return self._heightSpent != nil}
  /// Clears the value of `heightSpent`. Subsequent reads from it will return its default value.
  mutating func clearHeightSpent() {self._heightSpent = nil}

  /// The note position.
  var position: UInt64 = 0

  /// The source of the note (a tx hash or otherwise)
  var source: Penumbra_Core_Chain_V1alpha1_NoteSource {
    get {return _source ?? Penumbra_Core_Chain_V1alpha1_NoteSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment? = nil
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note? = nil
  fileprivate var _addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex? = nil
  fileprivate var _nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier? = nil
  fileprivate var _heightSpent: UInt64? = nil
  fileprivate var _source: Penumbra_Core_Chain_V1alpha1_NoteSource? = nil
}

/// A query for notes known by the view service.
///
/// This message uses the fact that all proto fields are optional
/// to allow various filtering on the returned notes.
struct Penumbra_View_V1alpha1_NotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the FVK for the notes to query.
  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  /// If set, return spent notes as well as unspent notes.
  var includeSpent: Bool = false

  /// If set, only return notes with the specified asset id.
  var assetID: Penumbra_Core_Crypto_V1alpha1_AssetId {
    get {return _assetID ?? Penumbra_Core_Crypto_V1alpha1_AssetId()}
    set {_assetID = newValue}
  }
  /// Returns true if `assetID` has been explicitly set.
  var hasAssetID: Bool {return self._assetID != nil}
  /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
  mutating func clearAssetID() {self._assetID = nil}

  /// If set, only return notes with the specified address incore.dex.v1alpha1.
  var addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex {
    get {return _addressIndex ?? Penumbra_Core_Crypto_V1alpha1_AddressIndex()}
    set {_addressIndex = newValue}
  }
  /// Returns true if `addressIndex` has been explicitly set.
  var hasAddressIndex: Bool {return self._addressIndex != nil}
  /// Clears the value of `addressIndex`. Subsequent reads from it will return its default value.
  mutating func clearAddressIndex() {self._addressIndex = nil}

  /// If set, stop returning notes once the total exceeds this amount.
  ///
  /// Ignored if `asset_id` is unset or if `include_spent` is set.
  var amountToSpend: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
  fileprivate var _assetID: Penumbra_Core_Crypto_V1alpha1_AssetId? = nil
  fileprivate var _addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex? = nil
}

struct Penumbra_View_V1alpha1_WitnessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the FVK for the note commitments to query.
  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  /// The note commitments to obtain auth paths for.
  var noteCommitments: [Penumbra_Core_Crypto_V1alpha1_NoteCommitment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
}

/// The plaintext of a note that has been quarantined until the end of an unbonding period.
struct Penumbra_View_V1alpha1_QuarantinedNoteRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The note commitment, identifying the note.
  var noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment {
    get {return _noteCommitment ?? Penumbra_Core_Crypto_V1alpha1_NoteCommitment()}
    set {_noteCommitment = newValue}
  }
  /// Returns true if `noteCommitment` has been explicitly set.
  var hasNoteCommitment: Bool {return self._noteCommitment != nil}
  /// Clears the value of `noteCommitment`. Subsequent reads from it will return its default value.
  mutating func clearNoteCommitment() {self._noteCommitment = nil}

  /// The note plaintext itself.
  var note: Penumbra_Core_Crypto_V1alpha1_Note {
    get {return _note ?? Penumbra_Core_Crypto_V1alpha1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  /// A precomputed decryption of the note's address incore.dex.v1alpha1.
  var addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex {
    get {return _addressIndex ?? Penumbra_Core_Crypto_V1alpha1_AddressIndex()}
    set {_addressIndex = newValue}
  }
  /// Returns true if `addressIndex` has been explicitly set.
  var hasAddressIndex: Bool {return self._addressIndex != nil}
  /// Clears the value of `addressIndex`. Subsequent reads from it will return its default value.
  mutating func clearAddressIndex() {self._addressIndex = nil}

  /// The height at which the note was created.
  var heightCreated: UInt64 = 0

  /// The epoch at which the note will exit quarantine, if unbonding is not interrupted by slashing.
  var unbondingEpoch: UInt64 = 0

  /// The validator identity the quarantining is bound to.
  var identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey {
    get {return _identityKey ?? Penumbra_Core_Crypto_V1alpha1_IdentityKey()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  /// The source of the note (a tx hash or otherwise)
  var source: Penumbra_Core_Chain_V1alpha1_NoteSource {
    get {return _source ?? Penumbra_Core_Chain_V1alpha1_NoteSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _noteCommitment: Penumbra_Core_Crypto_V1alpha1_NoteCommitment? = nil
  fileprivate var _note: Penumbra_Core_Crypto_V1alpha1_Note? = nil
  fileprivate var _addressIndex: Penumbra_Core_Crypto_V1alpha1_AddressIndex? = nil
  fileprivate var _identityKey: Penumbra_Core_Crypto_V1alpha1_IdentityKey? = nil
  fileprivate var _source: Penumbra_Core_Chain_V1alpha1_NoteSource? = nil
}

/// A query for quarantined notes known by the view service.
struct Penumbra_View_V1alpha1_QuarantinedNotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies the FVK for the notes to query.
  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
}

struct Penumbra_View_V1alpha1_NullifierStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountID: Penumbra_Core_Crypto_V1alpha1_AccountID {
    get {return _accountID ?? Penumbra_Core_Crypto_V1alpha1_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  mutating func clearAccountID() {self._accountID = nil}

  var nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier {
    get {return _nullifier ?? Penumbra_Core_Crypto_V1alpha1_Nullifier()}
    set {_nullifier = newValue}
  }
  /// Returns true if `nullifier` has been explicitly set.
  var hasNullifier: Bool {return self._nullifier != nil}
  /// Clears the value of `nullifier`. Subsequent reads from it will return its default value.
  mutating func clearNullifier() {self._nullifier = nil}

  var awaitDetection: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountID: Penumbra_Core_Crypto_V1alpha1_AccountID? = nil
  fileprivate var _nullifier: Penumbra_Core_Crypto_V1alpha1_Nullifier? = nil
}

struct Penumbra_View_V1alpha1_NullifierStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Penumbra_View_V1alpha1_TransactionPerspectiveRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionPerspectiveResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionsRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionByHashRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionHashStreamResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionStreamResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_TransactionByHashResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_NoteByCommitmentRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_ChainParamsRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_FMDParametersRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_AssetRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_StatusRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_StatusResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_StatusStreamRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_StatusStreamResponse: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_SpendableNoteRecord: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_NotesRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_WitnessRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_QuarantinedNoteRecord: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_QuarantinedNotesRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_NullifierStatusRequest: @unchecked Sendable {}
extension Penumbra_View_V1alpha1_NullifierStatusResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "penumbra.view.v1alpha1"

extension Penumbra_View_V1alpha1_TransactionPerspectiveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionPerspectiveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionPerspectiveRequest, rhs: Penumbra_View_V1alpha1_TransactionPerspectiveRequest) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionPerspectiveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionPerspectiveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txp"),
    2: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._txp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._txp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionPerspectiveResponse, rhs: Penumbra_View_V1alpha1_TransactionPerspectiveResponse) -> Bool {
    if lhs._txp != rhs._txp {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_height"),
    2: .standard(proto: "end_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._startHeight) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._endHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startHeight {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endHeight {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionsRequest, rhs: Penumbra_View_V1alpha1_TransactionsRequest) -> Bool {
    if lhs._startHeight != rhs._startHeight {return false}
    if lhs._endHeight != rhs._endHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionByHashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionByHashRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionByHashRequest, rhs: Penumbra_View_V1alpha1_TransactionByHashRequest) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionHashStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionHashStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .standard(proto: "tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionHashStreamResponse, rhs: Penumbra_View_V1alpha1_TransactionHashStreamResponse) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.txHash != rhs.txHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .standard(proto: "tx_hash"),
    3: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 2)
    }
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionStreamResponse, rhs: Penumbra_View_V1alpha1_TransactionStreamResponse) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.txHash != rhs.txHash {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_TransactionByHashResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionByHashResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_TransactionByHashResponse, rhs: Penumbra_View_V1alpha1_TransactionByHashResponse) -> Bool {
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_NoteByCommitmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoteByCommitmentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "note_commitment"),
    3: .standard(proto: "await_detection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._noteCommitment) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.awaitDetection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._noteCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.awaitDetection != false {
      try visitor.visitSingularBoolField(value: self.awaitDetection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_NoteByCommitmentRequest, rhs: Penumbra_View_V1alpha1_NoteByCommitmentRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs._noteCommitment != rhs._noteCommitment {return false}
    if lhs.awaitDetection != rhs.awaitDetection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_ChainParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_ChainParamsRequest, rhs: Penumbra_View_V1alpha1_ChainParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_FMDParametersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FMDParametersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_FMDParametersRequest, rhs: Penumbra_View_V1alpha1_FMDParametersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_AssetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_AssetRequest, rhs: Penumbra_View_V1alpha1_AssetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_StatusRequest, rhs: Penumbra_View_V1alpha1_StatusRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sync_height"),
    2: .standard(proto: "catching_up"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.syncHeight) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.catchingUp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.syncHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.syncHeight, fieldNumber: 1)
    }
    if self.catchingUp != false {
      try visitor.visitSingularBoolField(value: self.catchingUp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_StatusResponse, rhs: Penumbra_View_V1alpha1_StatusResponse) -> Bool {
    if lhs.syncHeight != rhs.syncHeight {return false}
    if lhs.catchingUp != rhs.catchingUp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_StatusStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_StatusStreamRequest, rhs: Penumbra_View_V1alpha1_StatusStreamRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_StatusStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latest_known_block_height"),
    2: .standard(proto: "sync_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.latestKnownBlockHeight) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.syncHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latestKnownBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestKnownBlockHeight, fieldNumber: 1)
    }
    if self.syncHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.syncHeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_StatusStreamResponse, rhs: Penumbra_View_V1alpha1_StatusStreamResponse) -> Bool {
    if lhs.latestKnownBlockHeight != rhs.latestKnownBlockHeight {return false}
    if lhs.syncHeight != rhs.syncHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_SpendableNoteRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpendableNoteRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_commitment"),
    2: .same(proto: "note"),
    3: .standard(proto: "address_index"),
    4: .same(proto: "nullifier"),
    5: .standard(proto: "height_created"),
    6: .standard(proto: "height_spent"),
    7: .same(proto: "position"),
    8: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._noteCommitment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._addressIndex) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nullifier) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.heightCreated) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._heightSpent) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.position) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._noteCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._addressIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nullifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.heightCreated != 0 {
      try visitor.visitSingularUInt64Field(value: self.heightCreated, fieldNumber: 5)
    }
    try { if let v = self._heightSpent {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    if self.position != 0 {
      try visitor.visitSingularUInt64Field(value: self.position, fieldNumber: 7)
    }
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_SpendableNoteRecord, rhs: Penumbra_View_V1alpha1_SpendableNoteRecord) -> Bool {
    if lhs._noteCommitment != rhs._noteCommitment {return false}
    if lhs._note != rhs._note {return false}
    if lhs._addressIndex != rhs._addressIndex {return false}
    if lhs._nullifier != rhs._nullifier {return false}
    if lhs.heightCreated != rhs.heightCreated {return false}
    if lhs._heightSpent != rhs._heightSpent {return false}
    if lhs.position != rhs.position {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_NotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "include_spent"),
    3: .standard(proto: "asset_id"),
    4: .standard(proto: "address_index"),
    5: .standard(proto: "amount_to_spend"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeSpent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._assetID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._addressIndex) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.amountToSpend) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.includeSpent != false {
      try visitor.visitSingularBoolField(value: self.includeSpent, fieldNumber: 2)
    }
    try { if let v = self._assetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._addressIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.amountToSpend != 0 {
      try visitor.visitSingularUInt64Field(value: self.amountToSpend, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_NotesRequest, rhs: Penumbra_View_V1alpha1_NotesRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.includeSpent != rhs.includeSpent {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._addressIndex != rhs._addressIndex {return false}
    if lhs.amountToSpend != rhs.amountToSpend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_WitnessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WitnessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "note_commitments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.noteCommitments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.noteCommitments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noteCommitments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_WitnessRequest, rhs: Penumbra_View_V1alpha1_WitnessRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.noteCommitments != rhs.noteCommitments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_QuarantinedNoteRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuarantinedNoteRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_commitment"),
    2: .same(proto: "note"),
    3: .standard(proto: "address_index"),
    4: .standard(proto: "height_created"),
    5: .standard(proto: "unbonding_epoch"),
    6: .standard(proto: "identity_key"),
    7: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._noteCommitment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._addressIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.heightCreated) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.unbondingEpoch) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._identityKey) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._noteCommitment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._addressIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.heightCreated != 0 {
      try visitor.visitSingularUInt64Field(value: self.heightCreated, fieldNumber: 4)
    }
    if self.unbondingEpoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.unbondingEpoch, fieldNumber: 5)
    }
    try { if let v = self._identityKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_QuarantinedNoteRecord, rhs: Penumbra_View_V1alpha1_QuarantinedNoteRecord) -> Bool {
    if lhs._noteCommitment != rhs._noteCommitment {return false}
    if lhs._note != rhs._note {return false}
    if lhs._addressIndex != rhs._addressIndex {return false}
    if lhs.heightCreated != rhs.heightCreated {return false}
    if lhs.unbondingEpoch != rhs.unbondingEpoch {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_QuarantinedNotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuarantinedNotesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_QuarantinedNotesRequest, rhs: Penumbra_View_V1alpha1_QuarantinedNotesRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_NullifierStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NullifierStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "nullifier"),
    3: .standard(proto: "await_detection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nullifier) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.awaitDetection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nullifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.awaitDetection != false {
      try visitor.visitSingularBoolField(value: self.awaitDetection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_NullifierStatusRequest, rhs: Penumbra_View_V1alpha1_NullifierStatusRequest) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs._nullifier != rhs._nullifier {return false}
    if lhs.awaitDetection != rhs.awaitDetection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Penumbra_View_V1alpha1_NullifierStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NullifierStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.spent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.spent != false {
      try visitor.visitSingularBoolField(value: self.spent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Penumbra_View_V1alpha1_NullifierStatusResponse, rhs: Penumbra_View_V1alpha1_NullifierStatusResponse) -> Bool {
    if lhs.spent != rhs.spent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
